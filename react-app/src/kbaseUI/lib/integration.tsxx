import { Channel } from './windowChannel';
import { UserAuthorization } from '../redux/auth/store';

export interface IFrameParams {
    frameId: string;
    parentHost: string;
    channelId: string;
    params: {
        originalPath: string;
        routeParams: object;
    };
}

export default class Integration {
    rootWindow: Window;
    hostParams: IFrameParams;
    hostChannelId: string;
    pluginParams: any;
    authorized: boolean;
    channel: Channel;
    authorization: UserAuthorization | null;
    config: any;

    constructor(rootWindow: Window) {
        this.rootWindow = rootWindow;
        // this.container = rootWindow.document.body;
        // channelId, frameId, hostId, parentHost
        this.hostParams = this.getParamsFromIFrame();
        this.hostChannelId = this.hostParams.channelId;

        // The original params from the plugin (taken from the url)
        this.pluginParams = this.hostParams.params;

        this.authorized = false;

        this.channel = new Channel({
            window: this.rootWindow,
            host: document.location.origin,
            channelId: this.hostChannelId
        });

        this.authorization = null;

        // this.runtime = null;
    }

    getParamsFromIFrame(): IFrameParams {
        if (!this.rootWindow.frameElement.hasAttribute('data-params')) {
            throw new Error('No params found in window!!');
        }
        const params = this.rootWindow.frameElement.getAttribute('data-params');
        if (!params) {
            throw new Error('Cannot get params from iframe');
        }
        return JSON.parse(decodeURIComponent(params)) as IFrameParams;
    }
    // onNavigate(listener) {
    //     this.navigationListeners.push(listener);
    //     if (this.navigationListeners.length === 1) {
    //         const queue = this.navigationQueue;
    //         this.navigationQueue = [];
    //         queue.forEach(({ path, params }) => {
    //             this.navigationListeners.forEach((listener) => {
    //                 listener({ path, params });
    //             });
    //         });
    //     }
    // }

    // handleNavigation({ path, params }) {
    //     // If no listeners yet, queue up the navigation.
    //     if (this.navigationListeners.length === 0) {
    //         this.navigationQueue.push({ path, params });
    //     } else {
    //         this.navigationListeners.forEach((listener) => {
    //             listener({ path, params });
    //         });
    //     }
    // }

    setupListeners() {
        // this.channel.on('navigate', (message) => {
        //     const { path, params } = message;
        //     // TODO: proper routing to error page
        //     if ((!path || path.length === 0) && !params.view) {
        //         alert('no view provided...');
        //         return;
        //     }
        //     this.handleNavigation({ path, params });
        // });
    }

    setupRuntimeListeners() {
        // this.runtime.messenger.receive({
        //     channel: 'app',
        //     message: 'navigate',
        //     handler: (to) => {
        //         this.channel.send('ui-navigate', to);
        //     }
        // });
        // this.runtime.messenger.receive({
        //     channel: 'app',
        //     message: 'post-form',
        //     handler: ({ action, params }) => {
        //         this.channel.send('post-form', { action, params });
        //     }
        // });
        // this.runtime.messenger.receive({
        //     channel: 'ui',
        //     message: 'setTitle',
        //     handler: (title) => {
        //         this.channel.send('set-title', { title });
        //     }
        // });
    }

    started() {
        this.channel.send('started', {});
    }

    start() {
        return new Promise((resolve, reject) => {
            this.channel.start();

            // The start event is built in to the integration.
            // It means that the parent context (ui) has received the
            // ready message, is itself ready, and is ready for
            // the iframe app to start running.
            this.channel.on(
                'start',
                (payload: any) => {
                    const { token, username, config, realname, email, roles } = payload;
                    if (token) {
                        this.authorization = { token, username, realname, roles };
                    } else {
                        this.authorization = null;
                    }
                    // this.token = token;
                    // this.username = username;
                    this.config = config;
                    this.authorized = token ? true : false;

                    // this.runtime = new Runtime({
                    //     config,
                    //     token,
                    //     username,
                    //     pluginConfigDB: this.pluginConfigDB
                    // });

                    // this.runtime
                    //     .start()
                    //     .then(() => {
                    //         this.setupListeners();
                    //         this.setupRuntimeListeners();
                    //         resolve();
                    //     })
                    //     .catch((err) => {
                    //         reject(err);
                    //     });
                },
                (error: Error) => {
                    console.log('error starting', error);
                }
            );

            window.document.addEventListener('click', () => {
                this.channel.send('clicked', {});
            });

            // Sending 'ready' with our channel id and host name allows the
            // enclosing app (window) to send us messages on our very own channel.
            // We could just use the host's channel, have all sends and receives
            // on the same channel, with control via the channel id. However, there is a risk
            // the the channels will listen on for the same message ... unlikely though.
            // Still, it would be odd for one window to listen for messages on another...
            this.channel.send('ready', {});
        });
    }

    stop() {}
}
